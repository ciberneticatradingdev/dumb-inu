---
import Layout from '../layouts/Layout.astro';
---

<Layout 
  title="Dumb Inu Flappy Bird - Play the Game!"
  description="Play the official Dumb Inu Flappy Bird game. Navigate through obstacles and beat your high score!"
  keywords="dumb inu game, flappy bird, dumb inu memecoin, browser game"
  canonicalURL=""
  robots="index, follow"
>
  <div id="walletProvider"></div>
  <div id="gameContainer" class="w-full h-screen bg-[#f5c303] flex items-center justify-center overflow-hidden">
    <canvas id="gameCanvas" class="md:border-2 md:border-white/20 md:rounded-lg md:shadow-2xl"></canvas>
    
    <!-- Game UI Overlay -->
    <div id="gameUI" class="absolute inset-0 pointer-events-none">
      <!-- Start Screen -->
      <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 pointer-events-auto">
        <div class="text-center p-8 bg-white/10 backdrop-blur-md rounded-2xl border border-white/20 max-w-md mx-4">
          <div class="flex items-center justify-center gap-4 mb-4">
            <img src="/game/dumb-inu-rocket.png" alt="Dumb Inu" class="w-16 h-16" />
            <h1 class="text-4xl md:text-6xl font-bold text-white drop-shadow-lg">FLAPPY DUMB</h1>
          </div>
          <p class="text-lg md:text-xl text-white/90 mb-6">Tap or press SPACE to fly!</p>
          
          <!-- Game Mode Selection -->
          <div class="space-y-4">
            <button id="playAsGuestBtn" class="w-full bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-4 px-6 rounded-full text-lg transition-all transform hover:scale-105 shadow-lg">
              üéÆ Play as Guest
            </button>
            <button id="connectWalletBtn" class="w-full bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-4 px-6 rounded-full text-lg transition-all transform hover:scale-105 shadow-lg">
              üîó Connect Wallet & Play
            </button>
          </div>
          
          <p class="text-sm text-white/70 mt-4">
            Connect wallet to automatically save your scores!
          </p>
        </div>
      </div>
      
      <!-- Game Over Screen -->
      <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 pointer-events-auto hidden">
        <div class="text-center p-8 bg-white/10 backdrop-blur-md rounded-2xl border border-white/20 max-w-md mx-4">
          <h2 class="text-4xl md:text-5xl font-bold text-white mb-4 drop-shadow-lg">GAME OVER</h2>
          <div class="text-white mb-6">
            <p class="text-2xl mb-2">Score: <span id="finalScore" class="font-bold text-[#62a14d]">0</span></p>
            <p class="text-xl mb-2">Best: <span id="bestScore" class="font-bold text-yellow-400">0</span></p>
            <div id="rankingInfo" class="text-lg text-white/80 hidden">
              <p>Your Ranking: <span id="userRank" class="font-bold text-blue-300">#-</span></p>
            </div>
            
            <!-- Score Save Status -->
            <div id="scoreSaveStatus" class="mt-4 hidden">
              <p class="text-green-400 text-sm">‚úÖ Score saved automatically!</p>
            </div>
          </div>
          
          <!-- Guest Mode: Manual Wallet Entry -->
          <div id="guestScoreEntry" class="mb-6 hidden">
            <p class="text-white/90 mb-3 text-sm">Want to save your score? Enter your wallet address:</p>
            <div class="space-y-3">
              <input 
                type="text" 
                id="manualWalletInput" 
                placeholder="Enter wallet address..." 
                class="w-full px-4 py-2 rounded-lg bg-white/10 border border-white/30 text-white placeholder-white/50 focus:outline-none focus:border-purple-400"
              />
              <div class="flex gap-2">
                <button id="saveScoreBtn" class="flex-1 bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-2 px-4 rounded-lg text-sm transition-all">
                  üíæ Save Score
                </button>
                <button id="skipSaveBtn" class="flex-1 bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-2 px-4 rounded-lg text-sm transition-all">
                  Skip
                </button>
              </div>
            </div>
          </div>
          
          <div class="flex gap-4 justify-center flex-wrap">
            <button id="restartBtn" class="bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-4 px-6 rounded-full text-lg transition-all transform hover:scale-105 shadow-lg">
              PLAY AGAIN
            </button>
            <a href="/leaderboard" class="bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-4 px-6 rounded-full text-lg transition-all transform hover:scale-105 shadow-lg hover:no-underline">
              VIEW LEADERBOARD
            </a>
          </div>
        </div>
      </div>
      
      <!-- Score Display -->
      <div id="scoreDisplay" class="absolute top-8 left-1/2 transform -translate-x-1/2 text-white text-4xl font-bold drop-shadow-lg hidden">
        <span id="currentScore">0</span>
      </div>
      
      <!-- Top Navigation -->
      <div class="absolute top-4 left-4 md:top-4 md:left-4 pointer-events-auto z-50 flex gap-2">
        <a href="/" class="bg-white/20 hover:bg-white/30 backdrop-blur-md text-white font-bold py-3 px-5 md:py-2 md:px-4 rounded-full text-base md:text-sm transition-all transform hover:scale-105 border border-white/30 hover:no-underline shadow-lg">
          üè† Home
        </a>
        <a href="/leaderboard" class="bg-white/20 hover:bg-white/30 backdrop-blur-md text-white font-bold py-3 px-5 md:py-2 md:px-4 rounded-full text-base md:text-sm transition-all transform hover:scale-105 border border-white/30 hover:no-underline shadow-lg">
          üèÜ Leaderboard
        </a>

      </div>
      
      <!-- Wallet Controls -->
      <div id="walletControls" class="absolute top-4 right-4 md:top-4 md:right-4 pointer-events-auto z-50">
        <!-- Guest Mode: Connect Wallet Button -->
        <div id="guestWalletControl" class="hidden">
          <button id="topConnectWalletBtn" class="bg-[#fa7e01] hover:bg-[#e06d00] backdrop-blur-md text-white font-bold py-2 px-4 rounded-full text-sm border border-white/30 transition-all transform hover:scale-105 shadow-lg">
            üîó Connect Wallet
          </button>
        </div>
        
        <!-- Logged Mode: Wallet Status with Disconnect Option -->
        <div id="loggedWalletControl" class="hidden relative">
          <div id="walletDisplay" class="bg-white/20 backdrop-blur-md text-white font-bold py-2 px-4 rounded-full text-sm border border-white/30 cursor-pointer hover:bg-white/30 transition-all">
            <p class="text-white/90">üîó <span id="walletAddressShort" class="font-mono text-green-300"></span></p>
          </div>
          
          <!-- Disconnect Dropdown -->
          <div id="walletDropdown" class="absolute top-full right-0 mt-2 bg-black/80 backdrop-blur-md rounded-lg border border-white/30 p-2 min-w-48 hidden">
            <div class="text-white/70 text-xs mb-2 font-mono break-all" id="walletAddressFull"></div>
            <button id="disconnectWalletBtn" class="w-full bg-[#fa7e01] hover:bg-[#e06d00] text-white font-bold py-2 px-3 rounded text-sm transition-all">
              üîå Disconnect Wallet
            </button>
          </div>
        </div>
      </div>
      
      <!-- Mobile Controls Hint -->
      <div id="mobileHint" class="absolute bottom-8 left-1/2 transform -translate-x-1/2 text-white/70 text-center hidden">
        <p class="text-lg">Tap anywhere to fly!</p>
      </div>
    </div>
  </div>
</Layout>

<style>
  /* Fullscreen styles for all devices */
  html, body {
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height */
    overflow: hidden;
    margin: 0;
    padding: 0;
  }
  
  #gameContainer {
    padding: 0 !important;
    margin: 0 !important;
    width: 100vw;
    height: 100vh;
    height: 100dvh;
  }
  
  #gameCanvas {
    display: block;
    margin: 0 !important;
    padding: 0 !important;
  }
  
  /* Mobile specific adjustments */
  @media (max-width: 768px) {
    /* Mobile Home Button Improvements */
    #gameUI > div:first-of-type {
      top: 8px !important;
      left: 8px !important;
      z-index: 9999 !important;
    }
    
    #gameUI > div:first-of-type a {
      background: rgba(0, 0, 0, 0.7) !important;
      backdrop-filter: blur(10px) !important;
      border: 2px solid rgba(255, 255, 255, 0.8) !important;
      font-size: 14px !important;
      padding: 8px 12px !important;
      min-height: 40px !important;
      min-width: 40px !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
    }
    
    /* Hide wallet controls completely on mobile */
    #walletControls {
      display: none !important;
    }
  }
  
  /* Desktop fullscreen optimizations */
  @media (min-width: 769px) {
    #gameContainer {
      width: 100vw;
      height: 100vh;
    }
    
    #gameCanvas {
      width: 100vw !important;
      height: 100vh !important;
    }
  }
</style>

<script type="module">
  // Game state management
  let gameMode = 'guest'; // 'guest' or 'wallet'
  let walletConnected = false;
  let walletAddress = null;
  let userHasChosenMode = false; // Track if user has made their choice in this session
  
  // Wallet detection and readiness
  let walletReady = false;
  
  // Function to wait for wallet to be ready
  function waitForWallet(timeout = 3000) {
    return new Promise((resolve) => {
      const checkWallet = () => {
        if (window.solana && window.solana.isPhantom) {
          walletReady = true;
          resolve(true);
        } else if (window.solflare || window.backpack) {
          walletReady = true;
          resolve(true);
        }
      };
      
      // Check immediately
      checkWallet();
      
      // If not ready, wait for wallet to load
      if (!walletReady) {
        const interval = setInterval(() => {
          checkWallet();
          if (walletReady) {
            clearInterval(interval);
          }
        }, 100);
        
        // Timeout after specified time
        setTimeout(() => {
          clearInterval(interval);
          resolve(false);
        }, timeout);
      }
    });
  }
  
  // Wallet functionality
  async function connectWallet() {
    try {
      console.log('Starting wallet connection process...');
      
      // Check if Phantom is available immediately
      if (window.solana && window.solana.isPhantom) {
        console.log('Phantom detected, attempting to connect...');
        
        try {
          // Force disconnect first to ensure clean state
          if (window.solana.isConnected) {
            await window.solana.disconnect();
          }
          
          console.log('Requesting Phantom connection - this should show popup...');
          
          // Request connection - this MUST trigger the popup
          const response = await window.solana.connect();
          
          console.log('Phantom connection response:', response);
          
          if (response && response.publicKey) {
            walletAddress = response.publicKey.toString();
            walletConnected = true;
            console.log('Phantom connected successfully:', walletAddress);
            updateWalletStatus();
            return true;
          } else {
            throw new Error('No public key received from Phantom');
          }
        } catch (phantomError) {
          console.error('Phantom connection error:', phantomError);
          
          // If Phantom fails, try other wallets as fallback
          if (window.solflare) {
            console.log('Phantom failed, trying Solflare as fallback...');
            try {
              const response = await window.solflare.connect();
              if (response && response.publicKey) {
                walletAddress = response.publicKey.toString();
                walletConnected = true;
                console.log('Solflare connected as fallback:', walletAddress);
                updateWalletStatus();
                return true;
              }
            } catch (solflareError) {
              console.error('Solflare fallback also failed:', solflareError);
            }
          }
          
          if (window.backpack) {
            console.log('Trying Backpack as fallback...');
            try {
              const response = await window.backpack.connect();
              if (response && response.publicKey) {
                walletAddress = response.publicKey.toString();
                walletConnected = true;
                console.log('Backpack connected as fallback:', walletAddress);
                updateWalletStatus();
                return true;
              }
            } catch (backpackError) {
              console.error('Backpack fallback also failed:', backpackError);
            }
          }
          
          throw phantomError;
        }
      } else {
        // No Phantom detected, check for other wallets
        console.log('Phantom not detected, checking for other wallets...');
        
        if (window.solflare) {
          console.log('Solflare detected, attempting to connect...');
          try {
            const response = await window.solflare.connect();
            if (response && response.publicKey) {
              walletAddress = response.publicKey.toString();
              walletConnected = true;
              console.log('Solflare connected successfully:', walletAddress);
              updateWalletStatus();
              return true;
            }
          } catch (solflareError) {
            console.error('Solflare connection failed:', solflareError);
          }
        }
        
        if (window.backpack) {
          console.log('Backpack detected, attempting to connect...');
          try {
            const response = await window.backpack.connect();
            if (response && response.publicKey) {
              walletAddress = response.publicKey.toString();
              walletConnected = true;
              console.log('Backpack connected successfully:', walletAddress);
              updateWalletStatus();
              return true;
            }
          } catch (backpackError) {
            console.error('Backpack connection failed:', backpackError);
          }
        }
        
        // No supported wallet found
        console.log('No supported wallet detected');
        const installWallet = confirm('No Solana wallet detected. Would you like to install Phantom wallet?');
        if (installWallet) {
          window.open('https://phantom.app/', '_blank');
        }
        return false;
      }
    } catch (error) {
      console.error('Wallet connection failed:', error);
      
      // Handle specific error cases
      if (error.code === 4001 || error.message?.includes('rejected') || error.message?.includes('User rejected')) {
        alert('Wallet connection was rejected by user. Please try again and approve the connection.');
      } else if (error.code === -32002) {
        alert('Wallet connection request is already pending. Please check your wallet.');
      } else if (error.message?.includes('not found') || error.message?.includes('undefined')) {
        alert('Wallet not properly loaded. Please refresh the page and try again.');
      } else {
        alert(`Failed to connect wallet: ${error.message || 'Unknown error'}. Please make sure your wallet is unlocked and try again.`);
      }
      return false;
    }
  }
  
  function updateWalletStatus() {
    // Update wallet controls through the game instance if available
    if (window.gameInstance) {
      window.gameInstance.updateWalletControls();
    }
  }
  
  function disconnectWallet() {
    try {
      // Try to disconnect from any connected wallet
      if (window.solana && window.solana.isConnected) {
        window.solana.disconnect();
      } else if (window.solflare && window.solflare.isConnected) {
        window.solflare.disconnect();
      } else if (window.backpack && window.backpack.isConnected) {
        window.backpack.disconnect();
      }
    } catch (error) {
      console.log('Wallet disconnect error:', error);
    }
    
    walletConnected = false;
    walletAddress = null;
    updateWalletStatus();
    console.log('Wallet disconnected');
  }
  
  // Score submission
  async function submitScore(score, wallet = null) {
    try {
      const response = await fetch('/api/scores', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          score: score,
          wallet_address: wallet || walletAddress
        })
      });
      
      if (response.ok) {
        const result = await response.json();
        return { success: true, data: result };
      } else {
        throw new Error('Failed to submit score');
      }
    } catch (error) {
      console.error('Score submission failed:', error);
      return { success: false, error: error.message };
    }
  }
  
  // Get user ranking
  async function getUserRank(wallet) {
    try {
      const response = await fetch(`/api/user/${wallet}`);
      if (response.ok) {
        const data = await response.json();
        return data.rank || 0;
      }
    } catch (error) {
      console.error('Failed to get user rank:', error);
    }
    return 0;
  }
  
  class FlappyBird {
    constructor() {
      this.canvas = document.getElementById('gameCanvas');
      this.ctx = this.canvas.getContext('2d');
      this.setupCanvas();
      
      // Game state
      this.gameState = 'start'; // 'start', 'playing', 'gameOver'
      this.score = 0;
      this.bestScore = parseInt(localStorage.getItem('dumbInuBirdBest') || '0');
      this.lastScoreMilestone = 0; // Track last milestone for score sound
      this.inputBlocked = false; // Block input during score saving
      
      // Audio setup
      this.jumpSound = new Audio('/game/jump.mp3');
      this.scoreSound = new Audio('/game/score.mp3');
      this.jumpSound.volume = 0.3;
      this.scoreSound.volume = 0.4;
      this.audioEnabled = true;
      
      // Dumb Inu image setup
        this.dumbInuImage = new Image();
        this.dumbInuImage.src = '/game/dumb-inu-rocket.png';
      this.imageLoaded = false;
      this.dumbInuImage.onload = () => {
        this.imageLoaded = true;
      };
      this.dumbInuImage.onerror = () => {
          console.warn('Could not load dumb-inu-rocket.png, using fallback');
          this.imageLoaded = false;
        };
      
      // Preload audio
      this.preloadAudio();
      
      // Bird properties - adjusted for square image
      this.bird = {
        x: this.canvas.width * 0.2,
        y: this.canvas.height / 2,
        width: 60,
        height: 60,
        velocity: 0,
        gravity: 0.6,
        jumpPower: -12,
        rotation: 0
      };
      
      // Pipes
      this.pipes = [];
      this.pipeWidth = 80;
      this.pipeGap = 200;
      this.pipeSpeed = 3;
      
      // Background elements (clouds removed)
      
      // Animation
      this.lastTime = 0;
      this.animationId = null;
      
      this.setupEventListeners();
      this.updateUI();
      this.gameLoop(0);
    }
    
    preloadAudio() {
      // Preload audio files
      this.jumpSound.load();
      this.scoreSound.load();
      
      // Handle audio errors gracefully
      this.jumpSound.addEventListener('error', () => {
        console.warn('Could not load jump sound');
        this.audioEnabled = false;
      });
      
      this.scoreSound.addEventListener('error', () => {
        console.warn('Could not load score sound');
      });
    }
    
    playSound(sound) {
      if (!this.audioEnabled) return;
      
      try {
        sound.currentTime = 0;
        sound.play().catch(e => {
          console.warn('Audio play failed:', e);
        });
      } catch (e) {
        console.warn('Audio error:', e);
      }
    }
    
    setupCanvas() {
      const container = document.getElementById('gameContainer');
      const containerRect = container.getBoundingClientRect();
      
      // Detect mobile devices
      const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
      
      let canvasWidth, canvasHeight;
      
      if (isMobile) {
        // Mobile: use full screen
        canvasWidth = containerRect.width;
        canvasHeight = containerRect.height;
        
        // Remove any borders/padding on mobile
        this.canvas.style.border = 'none';
        this.canvas.style.borderRadius = '0';
        this.canvas.style.boxShadow = 'none';
      } else {
        // PC/Desktop: use full screen for all resolutions
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        
        // Remove borders for fullscreen experience
        this.canvas.style.border = 'none';
        this.canvas.style.borderRadius = '0';
        this.canvas.style.boxShadow = 'none';
      }
      
      this.canvas.width = canvasWidth;
      this.canvas.height = canvasHeight;
      this.canvas.style.width = canvasWidth + 'px';
      this.canvas.style.height = canvasHeight + 'px';
      
      // Update bird position based on canvas size
      if (this.bird) {
        this.bird.x = this.canvas.width * 0.2;
        this.bird.y = this.canvas.height / 2;
      }
    }
    
    setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!this.inputBlocked) {
            this.handleInput();
          }
        }
      });
      
      // Touch/mouse controls
      this.canvas.addEventListener('click', () => {
        if (!this.inputBlocked) {
          this.handleInput();
        }
      });
      this.canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!this.inputBlocked) {
          this.handleInput();
        }
      });
      
      // UI buttons - new authentication flow
      document.getElementById('playAsGuestBtn')?.addEventListener('click', () => this.startGameAsGuest());
      document.getElementById('connectWalletBtn')?.addEventListener('click', () => this.startGameWithWallet());
      document.getElementById('restartBtn')?.addEventListener('click', () => this.restartGame());
      
      // Guest mode score saving
      document.getElementById('saveScoreBtn')?.addEventListener('click', () => this.saveGuestScore());
      document.getElementById('skipSaveBtn')?.addEventListener('click', () => this.skipScoreSave());
      
      // Top wallet controls
      document.getElementById('topConnectWalletBtn')?.addEventListener('click', () => this.connectWalletFromTop());
      document.getElementById('walletDisplay')?.addEventListener('click', () => this.toggleWalletDropdown());
      document.getElementById('disconnectWalletBtn')?.addEventListener('click', () => this.disconnectWallet());
      
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('walletDropdown');
        const walletDisplay = document.getElementById('walletDisplay');
        if (dropdown && !dropdown.contains(e.target) && !walletDisplay.contains(e.target)) {
          dropdown.classList.add('hidden');
        }
      });
      

      
      // Resize handler
      window.addEventListener('resize', () => {
        this.setupCanvas();
      });
      
      // Mobile detection
      if ('ontouchstart' in window) {
        document.getElementById('mobileHint')?.classList.remove('hidden');
      }
    }
    
    handleInput() {
      if (this.gameState === 'start') {
        this.startGame();
      } else if (this.gameState === 'playing') {
        this.bird.velocity = this.bird.jumpPower;
        this.playSound(this.jumpSound);
      } else if (this.gameState === 'gameOver') {
        this.restartGame();
      }
    }
    
    startGameAsGuest() {
      gameMode = 'guest';
      userHasChosenMode = true;
      this.startGame();
    }
    
    async startGameWithWallet() {
      const connected = await connectWallet();
      if (connected) {
        gameMode = 'wallet';
        userHasChosenMode = true;
        this.startGame();
      } else {
        // If wallet connection fails, offer to play as guest
        if (confirm('Wallet connection failed. Would you like to play as guest instead?')) {
          this.startGameAsGuest();
        }
      }
    }
    
    async connectWalletFromTop() {
      const connected = await connectWallet();
      if (connected) {
        gameMode = 'wallet';
        userHasChosenMode = true;
        this.updateWalletControls();
        // If game is over, allow automatic score saving
        if (this.gameState === 'gameOver' && this.score > 0) {
          this.saveCurrentScore();
        }
      }
    }
    
    toggleWalletDropdown() {
      const dropdown = document.getElementById('walletDropdown');
      if (dropdown) {
        dropdown.classList.toggle('hidden');
      }
    }
    
    disconnectWallet() {
      disconnectWallet();
      gameMode = 'guest';
      this.updateWalletControls();
      // Hide dropdown
      document.getElementById('walletDropdown')?.classList.add('hidden');
    }
    
    async saveCurrentScore() {
      if (gameMode === 'wallet' && walletConnected && this.score > 0) {
        this.inputBlocked = true;
        try {
          const result = await submitScore(this.score);
          if (result.success) {
            document.getElementById('scoreSaveStatus').classList.remove('hidden');
            
            // Get and display user ranking
            const rank = await getUserRank(walletAddress);
            if (rank > 0) {
              const rankingInfo = document.getElementById('rankingInfo');
              const userRank = document.getElementById('userRank');
              if (rankingInfo && userRank) {
                userRank.textContent = `#${rank}`;
                rankingInfo.classList.remove('hidden');
              }
            }
          }
        } catch (error) {
          console.error('Error submitting score:', error);
        } finally {
          this.inputBlocked = false;
        }
      }
    }
    
    updateWalletControls() {
      const guestControl = document.getElementById('guestWalletControl');
      const loggedControl = document.getElementById('loggedWalletControl');
      
      if (gameMode === 'wallet' && walletConnected) {
        // Show logged wallet control
        guestControl?.classList.add('hidden');
        loggedControl?.classList.remove('hidden');
        
        // Update wallet address display
        const shortAddr = document.getElementById('walletAddressShort');
        const fullAddr = document.getElementById('walletAddressFull');
        if (shortAddr && fullAddr && walletAddress) {
          const short = walletAddress.slice(0, 4) + '...' + walletAddress.slice(-4);
          shortAddr.textContent = short;
          fullAddr.textContent = walletAddress;
        }
      } else {
        // Show guest wallet control
        guestControl?.classList.remove('hidden');
        loggedControl?.classList.add('hidden');
      }
    }
    

    

    

    
    startGame() {
      this.gameState = 'playing';
      this.score = 0;
      this.lastScoreMilestone = 0;
      this.bird.y = this.canvas.height / 2;
      this.bird.velocity = 0;
      this.pipes = [];
      this.addPipe();
      this.updateUI();
    }
    
    restartGame() {
      // If user has already chosen their mode in this session, restart directly
      if (userHasChosenMode) {
        this.startGame();
      } else {
        // Show the selection screen only if no choice has been made
        this.gameState = 'start';
        this.updateUI();
      }
    }
    
    async saveGuestScore() {
      const walletInput = document.getElementById('manualWalletInput');
      const walletAddr = walletInput.value.trim();
      
      if (!walletAddr) {
        alert('Please enter a valid wallet address');
        return;
      }
      
      const result = await submitScore(this.score, walletAddr);
      if (result.success) {
        alert('Score saved successfully!');
        this.hideGuestScoreEntry();
      } else {
        alert('Failed to save score. Please try again.');
      }
    }
    
    skipScoreSave() {
      this.hideGuestScoreEntry();
      // Don't restart the game, just hide the score entry
    }
    
    hideGuestScoreEntry() {
      document.getElementById('guestScoreEntry').classList.add('hidden');
    }
    
    initClouds() {
      // Clouds functionality removed
    }
    
    addPipe() {
      const minHeight = 50;
      const maxHeight = this.canvas.height - this.pipeGap - minHeight;
      const topHeight = minHeight + Math.random() * (maxHeight - minHeight);
      
      this.pipes.push({
        x: this.canvas.width,
        topHeight: topHeight,
        bottomY: topHeight + this.pipeGap,
        passed: false
      });
    }
    
    update(deltaTime) {
      if (this.gameState !== 'playing') return;
      
      // Update bird
      this.bird.velocity += this.bird.gravity;
      this.bird.y += this.bird.velocity;
      
      // Bird rotation based on velocity
      this.bird.rotation = Math.max(-0.5, Math.min(0.5, this.bird.velocity * 0.05));
      
      // Update pipes
      for (let i = this.pipes.length - 1; i >= 0; i--) {
        const pipe = this.pipes[i];
        pipe.x -= this.pipeSpeed;
        
        // Score when passing pipe
        if (!pipe.passed && pipe.x + this.pipeWidth < this.bird.x) {
          pipe.passed = true;
          this.score++;
          
          // Play score sound every 10 points
          if (this.score > 0 && this.score % 10 === 0 && this.score > this.lastScoreMilestone) {
            this.lastScoreMilestone = this.score;
            this.playSound(this.scoreSound);
          }
          
          this.updateUI();
        }
        
        // Remove off-screen pipes
        if (pipe.x + this.pipeWidth < 0) {
          this.pipes.splice(i, 1);
        }
      }
      
      // Add new pipes
      if (this.pipes.length === 0 || this.pipes[this.pipes.length - 1].x < this.canvas.width - 300) {
        this.addPipe();
      }
      
      // Check collisions
      this.checkCollisions();
      
      // Clouds removed
    }
    
    checkCollisions() {
      // Bird collision box (slightly smaller than visual size for better gameplay)
      const birdLeft = this.bird.x + 10;
      const birdRight = this.bird.x + this.bird.width - 10;
      const birdTop = this.bird.y + 10;
      const birdBottom = this.bird.y + this.bird.height - 10;
      
      // Ground and ceiling
      if (birdBottom > this.canvas.height || birdTop < 0) {
        this.gameOver();
        return;
      }
      
      // Pipe collisions
      for (const pipe of this.pipes) {
        if (birdRight > pipe.x && 
            birdLeft < pipe.x + this.pipeWidth) {
          if (birdTop < pipe.topHeight || 
              birdBottom > pipe.bottomY) {
            this.gameOver();
            return;
          }
        }
      }
    }
    
    async gameOver() {
      this.gameState = 'gameOver';
      if (this.score > this.bestScore) {
        this.bestScore = this.score;
        localStorage.setItem('dumbInuBirdBest', this.bestScore.toString());
      }
      
      // Handle score saving based on game mode
      if (gameMode === 'wallet' && walletConnected && this.score > 0) {
        // Block input during score saving
        this.inputBlocked = true;
        
        // Auto-save score for wallet users
        try {
          const result = await submitScore(this.score);
          if (result.success) {
            document.getElementById('scoreSaveStatus').classList.remove('hidden');
            
            // Get and display user ranking
            const rank = await getUserRank(walletAddress);
            if (rank > 0) {
              const rankingInfo = document.getElementById('rankingInfo');
              const userRank = document.getElementById('userRank');
              if (rankingInfo && userRank) {
                userRank.textContent = `#${rank}`;
                rankingInfo.classList.remove('hidden');
              }
            }
          }
        } catch (error) {
          console.error('Error submitting score:', error);
        } finally {
          // Unblock input after score saving is complete
          this.inputBlocked = false;
        }
      } else if (gameMode === 'guest' && this.score > 0) {
        // Show manual wallet entry for guest users
        document.getElementById('guestScoreEntry').classList.remove('hidden');
        document.getElementById('manualWalletInput').value = '';
      }
      
      this.updateUI();
    }
    
    draw() {
      // Clear canvas with solid background
      this.ctx.fillStyle = '#f5c303';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Clouds removed
      
      // Draw pipes
      this.drawPipes();
      
      // Draw bird
      this.drawBird();
    }
    
    drawClouds() {
      // Clouds functionality removed
    }
    
    drawPipes() {
      this.ctx.fillStyle = '#fa7e01';
      this.ctx.strokeStyle = '#e06d00';
      this.ctx.lineWidth = 3;
      
      this.pipes.forEach(pipe => {
        // Top pipe
        this.ctx.fillRect(pipe.x, 0, this.pipeWidth, pipe.topHeight);
        this.ctx.strokeRect(pipe.x, 0, this.pipeWidth, pipe.topHeight);
        
        // Bottom pipe
        this.ctx.fillRect(pipe.x, pipe.bottomY, this.pipeWidth, this.canvas.height - pipe.bottomY);
        this.ctx.strokeRect(pipe.x, pipe.bottomY, this.pipeWidth, this.canvas.height - pipe.bottomY);
        
        // Pipe caps
        const capHeight = 30;
        const capWidth = this.pipeWidth + 10;
        const capX = pipe.x - 5;
        
        // Top cap
        this.ctx.fillRect(capX, pipe.topHeight - capHeight, capWidth, capHeight);
        this.ctx.strokeRect(capX, pipe.topHeight - capHeight, capWidth, capHeight);
        
        // Bottom cap
        this.ctx.fillRect(capX, pipe.bottomY, capWidth, capHeight);
        this.ctx.strokeRect(capX, pipe.bottomY, capWidth, capHeight);
      });
    }
    
    drawBird() {
      this.ctx.save();
      this.ctx.translate(this.bird.x + this.bird.width / 2, this.bird.y + this.bird.height / 2);
      this.ctx.rotate(this.bird.rotation);
      
      if (this.imageLoaded && this.dumbInuImage.complete) {
        // Draw dumb inu image - square dimensions for 1:1 aspect ratio
        const imageSize = this.bird.width; // Use same width and height for square
        this.ctx.drawImage(
          this.dumbInuImage,
          -imageSize / 2,
          -imageSize / 2,
          imageSize,
          imageSize
        );
      } else {
        // Fallback: draw simple bird
        this.ctx.fillStyle = '#fde047';
        this.ctx.strokeStyle = '#eab308';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.ellipse(0, 0, this.bird.width / 2, this.bird.height / 2, 0, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Bird eye
        this.ctx.fillStyle = 'white';
        this.ctx.beginPath();
        this.ctx.arc(8, -5, 6, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.fillStyle = 'black';
        this.ctx.beginPath();
        this.ctx.arc(10, -5, 3, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Bird beak
        this.ctx.fillStyle = '#f97316';
        this.ctx.beginPath();
        this.ctx.moveTo(this.bird.width / 2, 0);
        this.ctx.lineTo(this.bird.width / 2 + 10, -2);
        this.ctx.lineTo(this.bird.width / 2 + 10, 2);
        this.ctx.closePath();
        this.ctx.fill();
      }
      
      this.ctx.restore();
    }
    
    updateUI() {
      const startScreen = document.getElementById('startScreen');
      const gameOverScreen = document.getElementById('gameOverScreen');
      const scoreDisplay = document.getElementById('scoreDisplay');
      const currentScore = document.getElementById('currentScore');
      const finalScore = document.getElementById('finalScore');
      const bestScore = document.getElementById('bestScore');
      
      switch (this.gameState) {
        case 'start':
          startScreen.classList.remove('hidden');
          gameOverScreen.classList.add('hidden');
          scoreDisplay.classList.add('hidden');
          // Reset game over screen elements
          document.getElementById('scoreSaveStatus').classList.add('hidden');
          document.getElementById('guestScoreEntry').classList.add('hidden');
          document.getElementById('rankingInfo').classList.add('hidden');
          break;
        case 'playing':
          startScreen.classList.add('hidden');
          gameOverScreen.classList.add('hidden');
          scoreDisplay.classList.remove('hidden');
          currentScore.textContent = this.score.toString();
          break;
        case 'gameOver':
          startScreen.classList.add('hidden');
          gameOverScreen.classList.remove('hidden');
          scoreDisplay.classList.add('hidden');
          finalScore.textContent = this.score.toString();
          bestScore.textContent = this.bestScore.toString();
          break;
      }
      
      // Update wallet controls
      this.updateWalletControls();
    }
    
    gameLoop(currentTime) {
      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;
      
      this.update(deltaTime);
      this.draw();
      
      this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
    }
  }
  
  // Initialize game when page loads
  document.addEventListener('DOMContentLoaded', async () => {
    // Initialize game
    const game = new FlappyBird();
    window.gameInstance = game; // Make game instance globally available
    
    // Initialize wallet controls
    game.updateWalletControls();
  });
</script>

<style>
  #gameCanvas {
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  @media (max-width: 768px) {
    #gameContainer {
      padding: 1rem;
    }
    
    #startScreen h1,
    #gameOverScreen h2 {
      font-size: 3rem;
    }
    
    #scoreDisplay {
      font-size: 2rem;
    }
  }
  
  @media (max-width: 480px) {
    #startScreen h1,
    #gameOverScreen h2 {
      font-size: 2rem;
    }
    
    #scoreDisplay {
      font-size: 1.5rem;
    }
    
    button {
      padding: 0.75rem 1.5rem !important;
      font-size: 1rem !important;
    }
  }
</style>