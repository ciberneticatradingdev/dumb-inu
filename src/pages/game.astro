---
import Layout from '../layouts/Layout.astro';
---

<Layout 
  title="Drog Flappy Bird - Play the Game!"
  description="Play the official Drog Flappy Bird game. Navigate through obstacles and beat your high score!"
  keywords="drog game, flappy bird, drog memecoin, browser game"
  canonicalURL="https://drog.fun/game"
  robots="index, follow"
>
  <div id="gameContainer" class="w-full h-screen bg-gradient-to-b from-[#00c0ff] to-[#0099cc] flex items-center justify-center overflow-hidden">
    <canvas id="gameCanvas" class="md:border-2 md:border-white/20 md:rounded-lg md:shadow-2xl"></canvas>
    
    <!-- Game UI Overlay -->
    <div id="gameUI" class="absolute inset-0 pointer-events-none">
      <!-- Start Screen -->
      <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 pointer-events-auto">
        <div class="text-center p-8 bg-white/10 backdrop-blur-md rounded-2xl border border-white/20">
          <div class="flex items-center justify-center gap-4 mb-4">
            <img src="/game/drog.png" alt="Drog" class="w-16 h-16" />
            <h1 class="text-6xl font-bold text-white drop-shadow-lg">FLAPPY DROG</h1>
          </div>
          <p class="text-xl text-white/90 mb-6">Tap or press SPACE to fly!</p>
          <button id="startBtn" class="bg-[#62a14d] hover:bg-[#4a8a3a] text-white font-bold py-4 px-8 rounded-full text-xl transition-all transform hover:scale-105 shadow-lg">
            START GAME
          </button>
        </div>
      </div>
      
      <!-- Game Over Screen -->
      <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 pointer-events-auto hidden">
        <div class="text-center p-8 bg-white/10 backdrop-blur-md rounded-2xl border border-white/20">
          <h2 class="text-5xl font-bold text-white mb-4 drop-shadow-lg">GAME OVER</h2>
          <div class="text-white mb-6">
            <p class="text-2xl mb-2">Score: <span id="finalScore" class="font-bold text-[#62a14d]">0</span></p>
            <p class="text-xl">Best: <span id="bestScore" class="font-bold text-yellow-400">0</span></p>
          </div>
          <button id="restartBtn" class="bg-[#62a14d] hover:bg-[#4a8a3a] text-white font-bold py-4 px-8 rounded-full text-xl transition-all transform hover:scale-105 shadow-lg">
            PLAY AGAIN
          </button>
        </div>
      </div>
      
      <!-- Score Display -->
      <div id="scoreDisplay" class="absolute top-8 left-1/2 transform -translate-x-1/2 text-white text-4xl font-bold drop-shadow-lg hidden">
        <span id="currentScore">0</span>
      </div>
      
      <!-- Home Button -->
      <div class="absolute top-4 left-4 md:top-4 md:left-4 pointer-events-auto z-50">
        <a href="/" class="bg-white/20 hover:bg-white/30 backdrop-blur-md text-white font-bold py-3 px-5 md:py-2 md:px-4 rounded-full text-base md:text-sm transition-all transform hover:scale-105 border border-white/30 hover:no-underline shadow-lg">
          üè† Home
        </a>
      </div>
      
      <!-- Mobile Controls Hint -->
      <div id="mobileHint" class="absolute bottom-8 left-1/2 transform -translate-x-1/2 text-white/70 text-center hidden">
        <p class="text-lg">Tap anywhere to fly!</p>
      </div>
    </div>
  </div>
</Layout>

<style>
  /* Mobile fullscreen styles */
  @media (max-width: 768px) {
    #gameContainer {
      padding: 0 !important;
      margin: 0 !important;
    }
    
    #gameCanvas {
      display: block;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Hide mobile browser UI */
    body {
      overflow: hidden;
    }
    
    /* Ensure full viewport usage */
    html, body {
      height: 100vh;
      height: 100dvh; /* Dynamic viewport height for mobile */
    }
    
    /* Mobile Home Button Improvements */
    #gameUI > div:first-of-type {
      top: 8px !important;
      left: 8px !important;
      z-index: 9999 !important;
    }
    
    #gameUI > div:first-of-type a {
      background: rgba(0, 0, 0, 0.7) !important;
      backdrop-filter: blur(10px) !important;
      border: 2px solid rgba(255, 255, 255, 0.8) !important;
      font-size: 16px !important;
      padding: 12px 20px !important;
      min-height: 44px !important;
      min-width: 44px !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
    }
  }
</style>

<script>
  class FlappyBird {
    constructor() {
      this.canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.setupCanvas();
      
      // Game state
      this.gameState = 'start'; // 'start', 'playing', 'gameOver'
      this.score = 0;
      this.bestScore = parseInt(localStorage.getItem('drogBirdBest') || '0');
      this.lastScoreMilestone = 0; // Track last milestone for score sound
      
      // Audio setup
      this.jumpSound = new Audio('/game/jump.mp3');
      this.scoreSound = new Audio('/game/score.mp3');
      this.jumpSound.volume = 0.3;
      this.scoreSound.volume = 0.4;
      this.audioEnabled = true;
      
      // Drog image setup
      this.drogImage = new Image();
      this.drogImage.src = '/game/drog.png';
      this.imageLoaded = false;
      this.drogImage.onload = () => {
        this.imageLoaded = true;
      };
      this.drogImage.onerror = () => {
        console.warn('Could not load drog.png, using fallback');
        this.imageLoaded = false;
      };
      
      // Preload audio
      this.preloadAudio();
      
      // Bird properties - adjusted for square image
      this.bird = {
        x: this.canvas.width * 0.2,
        y: this.canvas.height / 2,
        width: 60,
        height: 60,
        velocity: 0,
        gravity: 0.6,
        jumpPower: -12,
        rotation: 0
      };
      
      // Pipes
      this.pipes = [];
      this.pipeWidth = 80;
      this.pipeGap = 200;
      this.pipeSpeed = 3;
      
      // Background elements
      this.clouds = [];
      this.initClouds();
      
      // Animation
      this.lastTime = 0;
      this.animationId = null;
      
      this.setupEventListeners();
      this.updateUI();
      this.gameLoop(0);
    }
    
    preloadAudio() {
      // Preload audio files
      this.jumpSound.load();
      this.scoreSound.load();
      
      // Handle audio errors gracefully
      this.jumpSound.addEventListener('error', () => {
        console.warn('Could not load jump sound');
        this.audioEnabled = false;
      });
      
      this.scoreSound.addEventListener('error', () => {
        console.warn('Could not load score sound');
      });
    }
    
    playSound(sound) {
      if (!this.audioEnabled) return;
      
      try {
        sound.currentTime = 0;
        sound.play().catch(e => {
          console.warn('Audio play failed:', e);
        });
      } catch (e) {
        console.warn('Audio error:', e);
      }
    }
    
    setupCanvas() {
      const container = document.getElementById('gameContainer')!;
      const containerRect = container.getBoundingClientRect();
      
      // Detect mobile devices
      const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
      
      let canvasWidth, canvasHeight;
      
      if (isMobile) {
        // Mobile: use full screen
        canvasWidth = containerRect.width;
        canvasHeight = containerRect.height;
        
        // Remove any borders/padding on mobile
        this.canvas.style.border = 'none';
        this.canvas.style.borderRadius = '0';
        this.canvas.style.boxShadow = 'none';
      } else {
        // Desktop/Tablet: maintain aspect ratio with limits
        const maxWidth = Math.min(containerRect.width * 0.9, 800);
        const maxHeight = Math.min(containerRect.height * 0.9, 600);
        
        const aspectRatio = 4 / 3;
        canvasWidth = maxWidth;
        canvasHeight = maxWidth / aspectRatio;
        
        if (canvasHeight > maxHeight) {
          canvasHeight = maxHeight;
          canvasWidth = maxHeight * aspectRatio;
        }
      }
      
      this.canvas.width = canvasWidth;
      this.canvas.height = canvasHeight;
      this.canvas.style.width = canvasWidth + 'px';
      this.canvas.style.height = canvasHeight + 'px';
      
      // Update bird position based on canvas size
      if (this.bird) {
        this.bird.x = this.canvas.width * 0.2;
        this.bird.y = this.canvas.height / 2;
      }
    }
    
    setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          this.handleInput();
        }
      });
      
      // Touch/mouse controls
      this.canvas.addEventListener('click', () => this.handleInput());
      this.canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.handleInput();
      });
      
      // UI buttons
      document.getElementById('startBtn')?.addEventListener('click', () => this.startGame());
      document.getElementById('restartBtn')?.addEventListener('click', () => this.restartGame());
      
      // Resize handler
      window.addEventListener('resize', () => {
        this.setupCanvas();
        this.initClouds();
      });
      
      // Mobile detection
      if ('ontouchstart' in window) {
        document.getElementById('mobileHint')?.classList.remove('hidden');
      }
    }
    
    handleInput() {
      if (this.gameState === 'start') {
        this.startGame();
      } else if (this.gameState === 'playing') {
        this.bird.velocity = this.bird.jumpPower;
        this.playSound(this.jumpSound);
      } else if (this.gameState === 'gameOver') {
        this.restartGame();
      }
    }
    
    startGame() {
      this.gameState = 'playing';
      this.score = 0;
      this.lastScoreMilestone = 0;
      this.bird.y = this.canvas.height / 2;
      this.bird.velocity = 0;
      this.pipes = [];
      this.addPipe();
      this.updateUI();
    }
    
    restartGame() {
      this.startGame();
    }
    
    initClouds() {
      this.clouds = [];
      const cloudCount = Math.floor(this.canvas.width / 150);
      for (let i = 0; i < cloudCount; i++) {
        this.clouds.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height * 0.3,
          size: 30 + Math.random() * 40,
          speed: 0.5 + Math.random() * 1
        });
      }
    }
    
    addPipe() {
      const minHeight = 50;
      const maxHeight = this.canvas.height - this.pipeGap - minHeight;
      const topHeight = minHeight + Math.random() * (maxHeight - minHeight);
      
      this.pipes.push({
        x: this.canvas.width,
        topHeight: topHeight,
        bottomY: topHeight + this.pipeGap,
        passed: false
      });
    }
    
    update(deltaTime) {
      if (this.gameState !== 'playing') return;
      
      // Update bird
      this.bird.velocity += this.bird.gravity;
      this.bird.y += this.bird.velocity;
      
      // Bird rotation based on velocity
      this.bird.rotation = Math.max(-0.5, Math.min(0.5, this.bird.velocity * 0.05));
      
      // Update pipes
      for (let i = this.pipes.length - 1; i >= 0; i--) {
        const pipe = this.pipes[i];
        pipe.x -= this.pipeSpeed;
        
        // Score when passing pipe
        if (!pipe.passed && pipe.x + this.pipeWidth < this.bird.x) {
          pipe.passed = true;
          this.score++;
          
          // Play score sound every 10 points
          if (this.score > 0 && this.score % 10 === 0 && this.score > this.lastScoreMilestone) {
            this.lastScoreMilestone = this.score;
            this.playSound(this.scoreSound);
          }
          
          this.updateUI();
        }
        
        // Remove off-screen pipes
        if (pipe.x + this.pipeWidth < 0) {
          this.pipes.splice(i, 1);
        }
      }
      
      // Add new pipes
      if (this.pipes.length === 0 || this.pipes[this.pipes.length - 1].x < this.canvas.width - 300) {
        this.addPipe();
      }
      
      // Check collisions
      this.checkCollisions();
      
      // Update clouds
      this.clouds.forEach(cloud => {
        cloud.x -= cloud.speed;
        if (cloud.x + cloud.size < 0) {
          cloud.x = this.canvas.width;
          cloud.y = Math.random() * this.canvas.height * 0.3;
        }
      });
    }
    
    checkCollisions() {
      // Bird collision box (slightly smaller than visual size for better gameplay)
      const birdLeft = this.bird.x + 10;
      const birdRight = this.bird.x + this.bird.width - 10;
      const birdTop = this.bird.y + 10;
      const birdBottom = this.bird.y + this.bird.height - 10;
      
      // Ground and ceiling
      if (birdBottom > this.canvas.height || birdTop < 0) {
        this.gameOver();
        return;
      }
      
      // Pipe collisions
      for (const pipe of this.pipes) {
        if (birdRight > pipe.x && 
            birdLeft < pipe.x + this.pipeWidth) {
          if (birdTop < pipe.topHeight || 
              birdBottom > pipe.bottomY) {
            this.gameOver();
            return;
          }
        }
      }
    }
    
    gameOver() {
      this.gameState = 'gameOver';
      if (this.score > this.bestScore) {
        this.bestScore = this.score;
        localStorage.setItem('drogBirdBest', this.bestScore.toString());
      }
      this.updateUI();
    }
    
    draw() {
      // Clear canvas with gradient background
      const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
      gradient.addColorStop(0, '#00c0ff');
      gradient.addColorStop(1, '#0099cc');
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Draw clouds
      this.drawClouds();
      
      // Draw pipes
      this.drawPipes();
      
      // Draw bird
      this.drawBird();
    }
    
    drawClouds() {
      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      this.clouds.forEach(cloud => {
        this.ctx.beginPath();
        this.ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
        this.ctx.arc(cloud.x + cloud.size * 0.5, cloud.y, cloud.size * 0.8, 0, Math.PI * 2);
        this.ctx.arc(cloud.x + cloud.size, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
        this.ctx.fill();
      });
    }
    
    drawPipes() {
      this.ctx.fillStyle = '#62a14d';
      this.ctx.strokeStyle = '#4a8a3a';
      this.ctx.lineWidth = 3;
      
      this.pipes.forEach(pipe => {
        // Top pipe
        this.ctx.fillRect(pipe.x, 0, this.pipeWidth, pipe.topHeight);
        this.ctx.strokeRect(pipe.x, 0, this.pipeWidth, pipe.topHeight);
        
        // Bottom pipe
        this.ctx.fillRect(pipe.x, pipe.bottomY, this.pipeWidth, this.canvas.height - pipe.bottomY);
        this.ctx.strokeRect(pipe.x, pipe.bottomY, this.pipeWidth, this.canvas.height - pipe.bottomY);
        
        // Pipe caps
        const capHeight = 30;
        const capWidth = this.pipeWidth + 10;
        const capX = pipe.x - 5;
        
        // Top cap
        this.ctx.fillRect(capX, pipe.topHeight - capHeight, capWidth, capHeight);
        this.ctx.strokeRect(capX, pipe.topHeight - capHeight, capWidth, capHeight);
        
        // Bottom cap
        this.ctx.fillRect(capX, pipe.bottomY, capWidth, capHeight);
        this.ctx.strokeRect(capX, pipe.bottomY, capWidth, capHeight);
      });
    }
    
    drawBird() {
      this.ctx.save();
      this.ctx.translate(this.bird.x + this.bird.width / 2, this.bird.y + this.bird.height / 2);
      this.ctx.rotate(this.bird.rotation);
      
      if (this.imageLoaded && this.drogImage.complete) {
        // Draw drog image - square dimensions for 1:1 aspect ratio
        const imageSize = this.bird.width; // Use same width and height for square
        this.ctx.drawImage(
          this.drogImage,
          -imageSize / 2,
          -imageSize / 2,
          imageSize,
          imageSize
        );
      } else {
        // Fallback: draw simple bird
        this.ctx.fillStyle = '#fde047';
        this.ctx.strokeStyle = '#eab308';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.ellipse(0, 0, this.bird.width / 2, this.bird.height / 2, 0, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Bird eye
        this.ctx.fillStyle = 'white';
        this.ctx.beginPath();
        this.ctx.arc(8, -5, 6, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.fillStyle = 'black';
        this.ctx.beginPath();
        this.ctx.arc(10, -5, 3, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Bird beak
        this.ctx.fillStyle = '#f97316';
        this.ctx.beginPath();
        this.ctx.moveTo(this.bird.width / 2, 0);
        this.ctx.lineTo(this.bird.width / 2 + 10, -2);
        this.ctx.lineTo(this.bird.width / 2 + 10, 2);
        this.ctx.closePath();
        this.ctx.fill();
      }
      
      this.ctx.restore();
    }
    
    updateUI() {
      const startScreen = document.getElementById('startScreen')!;
      const gameOverScreen = document.getElementById('gameOverScreen')!;
      const scoreDisplay = document.getElementById('scoreDisplay')!;
      const currentScore = document.getElementById('currentScore')!;
      const finalScore = document.getElementById('finalScore')!;
      const bestScore = document.getElementById('bestScore')!;
      
      switch (this.gameState) {
        case 'start':
          startScreen.classList.remove('hidden');
          gameOverScreen.classList.add('hidden');
          scoreDisplay.classList.add('hidden');
          break;
        case 'playing':
          startScreen.classList.add('hidden');
          gameOverScreen.classList.add('hidden');
          scoreDisplay.classList.remove('hidden');
          currentScore.textContent = this.score.toString();
          break;
        case 'gameOver':
          startScreen.classList.add('hidden');
          gameOverScreen.classList.remove('hidden');
          scoreDisplay.classList.add('hidden');
          finalScore.textContent = this.score.toString();
          bestScore.textContent = this.bestScore.toString();
          break;
      }
    }
    
    gameLoop(currentTime) {
      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;
      
      this.update(deltaTime);
      this.draw();
      
      this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
    }
  }
  
  // Initialize game when page loads
  document.addEventListener('DOMContentLoaded', () => {
    new FlappyBird();
  });
</script>

<style>
  #gameCanvas {
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  
  @media (max-width: 768px) {
    #gameContainer {
      padding: 1rem;
    }
    
    #startScreen h1,
    #gameOverScreen h2 {
      font-size: 3rem;
    }
    
    #scoreDisplay {
      font-size: 2rem;
    }
  }
  
  @media (max-width: 480px) {
    #startScreen h1,
    #gameOverScreen h2 {
      font-size: 2rem;
    }
    
    #scoreDisplay {
      font-size: 1.5rem;
    }
    
    button {
      padding: 0.75rem 1.5rem !important;
      font-size: 1rem !important;
    }
  }
</style>